<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glass Metaballs with Environment Map</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body.hovering {
            cursor: grab;
        }

        body.dragging {
            cursor: grabbing;
        }

        #container {
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            background-color: rgba(0, 0, 0, 0.3);
            padding: 20px;
            border-radius: 10px;
        }

        #info .subtitle {
            font-size: 12px;
            margin-top: 5px;
            opacity: 0.8;
        }

        button {
            padding: 10px;
            margin-top: 10px;
            border-radius: 10px;
            border: none;
            transition: all 0.3s ease-in-out;
            color: white;
            font-weight: bold;
            background-color: rgb(0, 149, 255);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.513), inset 2px 2px 3px rgba(255, 255, 255, 0.396), inset -8px -8px 16px rgba(255, 255, 255, 0.285);

        }

        button:hover {
            cursor: pointer;
            transform: scale(1.1);
        }

        #toggle-page {
            background: linear-gradient(to right, rgb(0, 149, 255), rgb(89, 0, 255));
        }

        #toggle-modes {
            background: linear-gradient(to right, rgb(255, 77, 0), rgb(255, 247, 0));
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <div id="info">
        <div>Click and drag to move metaballs</div>
        <div class="subtitle">Glass metaballs morphing together</div>
        <button id="toggle-modes">Change materials</button>
        <br>
        <button id="toggle-page" onclick="window.location.href='index.html'">âœ¨ 2D colorful balls</button>

    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { MarchingCubes } from 'three/addons/objects/MarchingCubes.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const container = document.getElementById('container');

        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(10, 10, 10);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        container.appendChild(renderer.domElement);

        // Load real cubemap environment
        const cubeTextureLoader = new THREE.CubeTextureLoader();
        cubeTextureLoader.setPath('https://threejs.org/examples/textures/cube/Park3Med/');

        const envMap = cubeTextureLoader.load([
            'px.jpg', 'nx.jpg',
            'py.jpg', 'ny.jpg',
            'pz.jpg', 'nz.jpg'
        ]);

        scene.background = envMap;
        scene.environment = envMap;

        // Create marching cubes for metaballs
        const resolution = 80;
        const glassMaterial = new THREE.MeshPhysicalMaterial({
            metalness: 0,
            roughness: 0,
            transmission: 1,
            thickness: 0.5,
            envMap: envMap,
            envMapIntensity: 2.0,
            ior: 1.5,
            clearcoat: 1,
            clearcoatRoughness: 0,
            vertexColors: true,
        });
        const metalMaterial = new THREE.MeshPhysicalMaterial({
            metalness: 1,
            roughness: 0,
            transmission: 0,
            thickness: 0.5,
            envMap: envMap,
            envMapIntensity: 2.0,
            ior: 1.5,
            clearcoat: 1,
            clearcoatRoughness: 0,
            vertexColors: true,
        });

        const matteMaterial = new THREE.MeshBasicMaterial({
            wireframe: true,
            vertexColors: true,
            wireframeLinewidth: 2,
            side: THREE.DoubleSide,
        });
        let mode = 1;
        const materials = [matteMaterial, metalMaterial, glassMaterial];
        let currentMaterial = materials[mode];

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;
        controls.enableZoom = false;
        controls.enablePan = false;
        controls.enableRotate = false;

        let effect = new MarchingCubes(resolution, currentMaterial, true, true, 200000);

        effect.position.set(0, 0, 0);
        effect.scale.set(15, 15, 15);
        effect.enableUvs = false;
        effect.enableColors = (mode === 0 || mode === 1 || mode === 2); // Enable colors for metal material
        effect.isolation = 50;

        scene.add(effect);

        // Lighting
        const light1 = new THREE.DirectionalLight(0xffffff, 1);
        light1.position.set(5, 5, 5);
        scene.add(light1);

        const light2 = new THREE.DirectionalLight(0xffffff, 0.5);
        light2.position.set(-5, -5, 5);
        scene.add(light2);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        // Metaball data structure
        const numBlobs = 4;
        const metaballs = [];

        // Define vibrant colors for each metaball
        const ballColors = [
            new THREE.Color(0xff0080), // Hot pink
            new THREE.Color(0x00ffff), // Cyan
            new THREE.Color(0xffff00), // Yellow
            new THREE.Color(0x00ff80), // Spring green
        ];

        // Initialize metaballs in circular pattern
        for (let i = 0; i < numBlobs; i++) {
            const angle = (i / numBlobs) * Math.PI * 2;
            const radius = 0.15;
            metaballs.push({
                x: 0.5 + Math.cos(angle) * radius,
                y: 0.5,
                z: 0.5 + Math.sin(angle) * radius,
                vx: 0,
                vy: 0,
                vz: 0,
                strength: 1,
                subtract: 12,
                color: ballColors[i]
            });
        }

        // Raycaster for mouse picking
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let draggedBall = null;
        let isDragging = false;
        let hoveredBall = null;
        let dragPlane = new THREE.Plane();
        let dragOffset = new THREE.Vector3();

        // Check if mouse is over a ball
        function updateHover(event) {
            if (isDragging) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            let closestBall = null;
            let closestDistance = Infinity;

            metaballs.forEach((ball, index) => {
                const ballPos = new THREE.Vector3(
                    (ball.x - 0.5) * 10,
                    (ball.y - 0.5) * 10,
                    (ball.z - 0.5) * 10
                );

                const screenPos = ballPos.clone().project(camera);
                const dx = screenPos.x - mouse.x;
                const dy = screenPos.y - mouse.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < 0.3 && distance < closestDistance) {
                    closestDistance = distance;
                    closestBall = index;
                }
            });

            if (closestBall !== null) {
                hoveredBall = closestBall;
                document.body.classList.add('hovering');
            } else {
                hoveredBall = null;
                document.body.classList.remove('hovering');
            }
        }

        // Mouse events
        function onMouseDown(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Find closest metaball to mouse in screen space
            let closestBall = null;
            let closestDistance = Infinity;

            metaballs.forEach((ball, index) => {
                const ballPos = new THREE.Vector3(
                    (ball.x - 0.5) * 10,
                    (ball.y - 0.5) * 10,
                    (ball.z - 0.5) * 10
                );

                // Project ball position to screen space
                const screenPos = ballPos.clone().project(camera);

                // Calculate 2D distance in screen space
                const dx = screenPos.x - mouse.x;
                const dy = screenPos.y - mouse.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // Check if within reasonable grab distance
                if (distance < 0.3 && distance < closestDistance) {
                    closestDistance = distance;
                    closestBall = index;
                }
            });

            if (closestBall !== null) {
                draggedBall = closestBall;
                isDragging = true;
                document.body.classList.add('dragging');
                controls.autoRotate = false; // Pause rotation while dragging

                // Get the ball's world position
                const ballWorldPos = new THREE.Vector3(
                    (metaballs[draggedBall].x - 0.5) * 10,
                    (metaballs[draggedBall].y - 0.5) * 10,
                    (metaballs[draggedBall].z - 0.5) * 10
                );

                // Create a plane facing the camera, passing through the ball
                const planeNormal = new THREE.Vector3();
                planeNormal.subVectors(camera.position, ballWorldPos).normalize();
                dragPlane.setFromNormalAndCoplanarPoint(planeNormal, ballWorldPos);

                // Calculate initial intersection point and offset
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(dragPlane, intersectPoint);

                if (intersectPoint) {
                    dragOffset.copy(ballWorldPos).sub(intersectPoint);
                }
            }
        }

        function onMouseMove(event) {
            if (!isDragging || draggedBall === null) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Intersect with the drag plane
            const intersectPoint = new THREE.Vector3();
            raycaster.ray.intersectPlane(dragPlane, intersectPoint);

            if (intersectPoint) {
                // Add the offset to maintain grab position
                intersectPoint.add(dragOffset);

                // Convert back to metaball coordinates (0-1 range)
                metaballs[draggedBall].x = (intersectPoint.x / 20) + 0.5;
                metaballs[draggedBall].y = (intersectPoint.y / 20) + 0.5;
                metaballs[draggedBall].z = (intersectPoint.z / 20) + 0.5;

                // Clamp to bounds
                metaballs[draggedBall].x = Math.max(0.02, Math.min(0.98, metaballs[draggedBall].x));
                metaballs[draggedBall].y = Math.max(0.02, Math.min(0.98, metaballs[draggedBall].y));
                metaballs[draggedBall].z = Math.max(0.02, Math.min(0.98, metaballs[draggedBall].z));

                // Reset velocity when dragging
                metaballs[draggedBall].vx = 0;
                metaballs[draggedBall].vy = 0;
                metaballs[draggedBall].vz = 0;
            }
        }

        function toggleMode() {
            mode = (mode + 1) % 3;
            currentMaterial = materials[mode];
            scene.remove(effect);
            effect = new MarchingCubes(resolution, currentMaterial, true, true, 200000);

            effect.position.set(0, 0, 0);
            effect.scale.set(15, 15, 15);
            effect.enableUvs = false;
            effect.enableColors = (mode === 1 || mode === 0 || mode === 2); // Enable colors only for metal material
            effect.isolation = 50;
            scene.add(effect);
        }

        function onMouseUp() {
            isDragging = false;
            draggedBall = null;
            document.body.classList.remove('dragging');
            controls.autoRotate = true; // Resume rotation after dragging
        }

        window.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', (event) => {
            updateHover(event);
            onMouseMove(event);
        });
        window.addEventListener('mouseup', onMouseUp);
        document.getElementById('toggle-modes').addEventListener('click', toggleMode);
        // Animation
        let time = 0;

        function updateMetaballs() {
            effect.reset();

            // Update positions with gentle drift when not being dragged
            metaballs.forEach((ball, i) => {
                if (draggedBall !== i) {
                    // Gentle floating motion
                    ball.x += Math.sin(time * 0.5 + i) * 0.0005;
                    ball.y += Math.cos(time * 0.7 + i * 0.5) * 0.0003;
                    ball.z += Math.sin(time * 0.6 + i * 1.3) * 0.0005;

                    // Keep within bounds
                    ball.x = Math.max(0.02, Math.min(0.98, ball.x));
                    ball.y = Math.max(0.02, Math.min(0.98, ball.y));
                    ball.z = Math.max(0.02, Math.min(0.98, ball.z));
                }

                // Add ball with color if in metal mode
                if (mode === 1 || mode === 0 || mode === 2) {
                    effect.addBall(ball.x, ball.y, ball.z, ball.strength, ball.subtract, ball.color);
                } else {
                    effect.addBall(ball.x, ball.y, ball.z, ball.strength, ball.subtract);
                }
            });

            effect.update();
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.015;

            updateMetaballs();
            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>